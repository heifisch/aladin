<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="XRechnung" script:language="StarBasic" script:moduleType="normal">REM ***** BASIC *****
Option Explicit

Sub XRechnungMenu()
	If iDocTypID = 5 OR iDocTypID = 6 then
		If lDocumentID &gt; 0 then
			CreateMenuXRechnung()
		Else
			RemoveMenuXRechnung()
		End If
	Else
		RemoveMenuXRechnung()
	End If
End Sub

Sub RemoveMenuXRechnung()
	Dim oMmoduleCfgMgr As Object
	Dim oMenuBarSettings As Object
	Dim vPopupMenu As Variant
	Dim oPopupMenuContainer As Object
	Dim vMenuItem as Variant
	Dim sMenuBar As String
	Dim iCount As Integer
	Dim iRemoveItem As Integer
	Dim i, j, k, l, m As Integer

	iRemoveItem = -1
	sMenuBar = &quot;private:resource/menubar/menubar&quot;

	oMmoduleCfgMgr = ThisComponent.getUIConfigurationManager()
	oMenuBarSettings = oMmoduleCfgMgr.getSettings(sMenuBar, True)

	iCount = oMenuBarSettings.getCount()

	For i = 0 to iCount-1
		vPopupMenu() = oMenuBarSettings.getByIndex(i)
		For j = 0 To UBound(vPopupMenu) - 1
			If vPopupMenu(j).Name = &quot;Label&quot; And VarType(vPopupMenu(j).Value) = V_STRING Then
				If vPopupMenu(j).Value = &quot;ALADIN&quot; Then
					For k = 0 To UBound(vPopupMenu) - 1
						If vPopupMenu(k).Name = &quot;ItemDescriptorContainer&quot; Then
							oPopupMenuContainer = vPopupMenu(k).Value
 							For l = 0 To oPopupMenuContainer.Count() - 1
								vMenuItem=oPopupMenuContainer.getByIndex(l)
&apos;						Xray vMenuItem
								For m = 0 To UBound(vMenuItem) - 1
									If vMenuItem(m).Name = &quot;Label&quot; And VarType(vMenuItem(m).Value) = V_STRING Then
										If vMenuItem(m).Value = &quot;XRechnung&quot; Then
											iRemoveItem = l
											Exit For
										End if
									End if
								Next
							Next
						End If
					Next
				End If
			End If
		Next
 	Next
 	If iRemoveItem &gt; -1 then
		oPopupMenuContainer.removeByIndex(iRemoveItem)
		oPopupMenuContainer.removeByIndex(iRemoveItem-1)
		oMmoduleCfgMgr.replaceSettings(sMenuBar, oMenuBarSettings)		
	End If
End Sub

Sub CreateMenuXRechnung()
	Dim oMmoduleCfgMgr As Object
	Dim oMenuBarSettings As Object
	Dim vPopupMenu As Variant
	Dim vMenuItem as Variant
	Dim vSubMenuItem as Variant
	Dim vNewMenuItem as Variant
	Dim oPopupMenuContainer As Object
	Dim oPopupSubMenuContainer As Object
	Dim sMenuBar As String
	Dim sMyPopupMenuCmdId As String
	Dim iCount As Integer
	Dim iItemExists As Integer
	Dim i, j, k, l, m, n As Integer

	iItemExists = -1
	sMenuBar = &quot;private:resource/menubar/menubar&quot;
    sMyPopupMenuCmdId = &quot;vnd.openoffice.org:CustomMenu1&quot;

	oMmoduleCfgMgr = ThisComponent.getUIConfigurationManager()
	oMenuBarSettings = oMmoduleCfgMgr.getSettings(sMenuBar, True)

	iCount = oMenuBarSettings.getCount()

	For i = 0 to iCount-1
		vPopupMenu() = oMenuBarSettings.getByIndex(i)
		For j = 0 To UBound(vPopupMenu) - 1
			If vPopupMenu(j).Name = &quot;Label&quot; And VarType(vPopupMenu(j).Value) = V_STRING Then
				If vPopupMenu(j).Value = &quot;ALADIN&quot; Then
					For k = 0 To UBound(vPopupMenu) - 1
						If vPopupMenu(k).Name = &quot;ItemDescriptorContainer&quot; Then
							oPopupMenuContainer = vPopupMenu(k).Value
							For l = 0 To oPopupMenuContainer.Count() - 1
								vMenuItem=oPopupMenuContainer.getByIndex(l)
								For m = 0 To UBound(vMenuItem) - 1
									If vMenuItem(m).Name = &quot;Label&quot; And VarType(vMenuItem(m).Value) = V_STRING Then
										If vMenuItem(m).Value = &quot;XRechnung&quot; Then
											iItemExists=j
											Exit For
										End if
									End if
								Next
							Next
							if iItemexists &lt; 0 Then
						 		vNewMenuItem = fCreateMenuSeparator()
						 		oPopupMenuContainer.insertByIndex( oPopupMenuContainer.Count(), vNewMenuItem )

								vNewMenuItem = fCreatePopupMenu(sMyPopupMenuCmdId, &quot;XRechnung&quot;, oMenuBarSettings )
								oPopupMenuContainer.insertByIndex(oPopupMenuContainer.Count(), vNewMenuItem)
							End If
							For l = 0 To oPopupMenuContainer.Count() - 1
								vMenuItem=oPopupMenuContainer.getByIndex(l)

								For m = 0 To UBound(vMenuItem) - 1
									If vMenuItem(m).Name = &quot;Label&quot; And VarType(vMenuItem(m).Value) = V_STRING Then
										If vMenuItem(m).Value = &quot;XRechnung&quot; Then
											For n = 0 To UBound(vMenuItem) - 1
												If vMenuItem(n).Name = &quot;ItemDescriptorContainer&quot; Then
													oPopupSubMenuContainer = vMenuItem(n).Value
													vNewMenuItem = fCreateMenuItem(&quot;vnd.sun.star.script:Standard.XRechnung.XRechnung_erzeugen?language=Basic&amp;location=document&quot;, &quot;XRechnung erzeugen&quot;)
													oPopupSubMenuContainer.insertByIndex(oPopupSubMenuContainer.Count(), vNewMenuItem)													
													vNewMenuItem = fCreateMenuItem(&quot;vnd.sun.star.script:Standard.XRechnung.XRechnung_versenden?language=Basic&amp;location=document&quot;, &quot;XRechnung versenden&quot;)
													oPopupSubMenuContainer.insertByIndex(oPopupSubMenuContainer.Count(), vNewMenuItem)													
												End If
											Next
										End if
									End if
								Next
							Next
						End If
					Next
				End If
			End If
		Next
 	Next

	if iItemexists &lt; 0 Then
		oMmoduleCfgMgr.replaceSettings(sMenuBar, oMenuBarSettings)	
	End if
	
End Sub

Sub XRechnung_erzeugen()
	Dim sPraefix As String,stXRechnungDir As String,stXRechnungPath As String,stXRechnungBaseName As String
	Dim sValidatorReturnCode As String,sValidatorReturnCodeFile As String,sValidatorReportHtml as String,sValidatorReportXml as String
	Dim oShell As Object,oSimpleFileAccess As Object,oTextInputStream As Object,vStatus As Variant
	
	If iDocTypID = 5 Then
		If iOption_AZ = 1 then
			sPraefix=&quot;AZ&quot;
		else
			sPraefix=&quot;RE&quot;
		End if
	Elseif iDocTypID = 6 then
		sPraefix=&quot;GU&quot;
	End If
	
	stXRechnungDir = sPathAusgangsRechnungen &amp; &quot;/&quot; &amp; sPraefix &amp; CStr(lDocumentID)

	If NOT FileExists(ConvertToURL(stXRechnungDir)) then
		MkDir ConvertToURL(stXRechnungDir)
	End If
	
	stXRechnungBaseName = stXRechnungDir &amp; &quot;/&quot; &amp; sPraefix &amp; CStr(lDocumentID) &amp; &quot;_XRechnung&quot;
	
	If (iDocTypID = 5 or iDocTypID = 6) Then
		stXRechnungPath = stXRechnungBaseName &amp; &quot;.xml&quot;
		If FileExists(ConvertToURL(stXRechnungPath)) then
			vStatus=MsgBox(&quot;Es ist schon folgende XRechnung im Archiv abgelegt:&quot;&amp; Chr(13) &amp; Chr(13) &amp;_
				stXRechnungPath &amp; Chr(13) &amp; Chr(13) &amp; Chr(13) &amp;_
				&quot;Soll die vorhandene XRechnung überschrieben werden?&quot;,36,sTitle)
			If vStatus &lt;&gt; 6 Then
				MsgBox(&quot;Die vorhandene XRechnung wurde nicht überschrieben!&quot;,64,sTitle_lokal)
				exit Sub		
			End if
		End if
	End If
	
	Document_berechnen()
	SaveXRechnung(ConvertToURL(stXRechnungPath))

	If Not FileExists(ConvertToURL(stXRechnungPath)) Then
		MsgBox(&quot;XRechnung wurde nicht erzeugt!&quot;,64,sTitle_lokal)
		exit Sub		
	Else
		If Not FileExists(ConvertToURL(sPathXRechnungValidator)) Then
			MsgBox(&quot;Kein Validator gefunden!&quot;,64,sTitle_lokal)
			exit Sub		
		End If
	End If
	
	sValidatorReportHtml=ConvertToURL(stXRechnungBaseName &amp; &quot;-report.html&quot;)
	sValidatorReportXml=ConvertToURL(stXRechnungBaseName &amp; &quot;-report.xml&quot;)
	sValidatorReturnCodeFile=ConvertToURL(stXRechnungBaseName &amp; &quot;-returncode.txt&quot;)
	
	If FileExists(sValidatorReportHtml) Then Kill sValidatorReportHtml
	If FileExists(sValidatorReportXml) Then Kill sValidatorReportXml
	If FileExists(sValidatorReturnCodeFile) Then Kill sValidatorReturnCodeFile
	
	Shell(sPathXRechnungValidator,1,stXRechnungPath,True)
	
	oSimpleFileAccess = CreateUnoService(&quot;com.sun.star.ucb.SimpleFileAccess&quot;)
	oTextInputStream = CreateUnoService(&quot;com.sun.star.io.TextInputStream&quot;)

	If oSimpleFileAccess.Exists(sValidatorReturnCodeFile) Then
		oTextInputStream.setInputStream(oSimpleFileAccess.openFileRead(sValidatorReturnCodeFile))
		Do While Not oTextInputStream.isEOF
			sValidatorReturnCode=oTextInputStream.readLine
		Loop
		oTextInputStream.closeInput()
		If sValidatorReturnCode &lt;&gt; &quot;0&quot; Then
			If FileExists(sValidatorReportHtml) Then
				vStatus=MsgBox(&quot;Achtung! Es ist ein Fehler bei der Validierung der XRechnung aufgetreten!&quot; &amp; Chr$(13) &amp; Chr$(13) &amp;_
				&quot;Wollen Sie sich das Ergebnis der Validierung ansehen?&quot;,52,sTitle_lokal)
				if vStatus=6 Then
					oShell = createUnoService(&quot;com.sun.star.system.SystemShellExecute&quot;)
					oShell.execute(sValidatorReportHtml,&quot;&quot;,0)
				End If
			Else
				MsgBox(&quot;Es ist ein Fehler bei der Validierung der XRechnung aufgetreten!&quot; &amp; Chr$(13) &amp; Chr$(13) &amp;_
				&quot;Fehlercode: &quot;&amp; sValidatorReturnCode,64,sTitle_lokal)
			End If
		End if
	Else
		MsgBox(&quot;Es wurde kein Return-Code vom Validator gefunden!&quot;,64,sTitle_lokal)
	End if
End Sub

Sub XRechnung_versenden()
	print &quot;XRechnung versenden&quot;
End Sub

REM Folgender Code basiert auf den Code aus dem Program XRechnung von Robert Großkopf https://www.familiegrosskopf.de/robert/

REM XRechnungen dürfen nach 2 verschiedenen System erstellt werden.
REM Dies sind ISO/IEC 19845 Information technology — Universal business language version 2.1 (in der Spezifikation Standard XRechnung als &quot;UBL&quot; abgekürzt)
REM und UN/CEFACT Cross Industry Invoice in XML Schemas 16B (in der Spezifikation Standard XRechnung als &quot;CII&quot; abgekürzt).
REM Die Rechnung wird in der folgenden Prozedur nach dem UBL-System erstellt (beginnend mit &lt;ubl:Invoice:
REM +++ Wird aus &quot;Druck → ExportPDF&quot; aufgerufen
SUB SaveXRechnung(stXRechnungPath AS String)
	Dim vStatus as Variant
	Dim sSQL1 as String,sSQL2 as String,sSQL3 as String,sSQL4 as String,sSQL5 as String
	Dim oRecord1 as Object,oRecord2 as Object,oRecord3 as Object
	Dim	iOptionInhaber as Integer,sGeschaeftsfuehrer as String,sHRB as String,sAmtsgericht as String,sSitz as String
	Dim sHREintragForm As String,sPraefix As String,sInvoiceTypeCode As String,stSkontoSatz As String,stSkontoTage As String,stSkontoBis As String,stSkonto As String
	Dim sAZ_Text As String


	DIM oUcb AS OBJECT, oOutputStream AS OBJECT, oFile AS OBJECT
	DIM stID AS STRING, stSql AS STRING, stNetto AS STRING, stSteuer AS STRING, stBrutto AS STRING
	DIM stRStellFirma AS STRING, stRStellStr AS STRING, stRStellPlz AS STRING, stRStellStadt AS STRING, stRStellEMail AS STRING, stRStellTel AS STRING, stRStellUST_IdNr AS STRING
	DIM stRStellAbwHandelsname AS STRING, stZahlungIBAN AS STRING, stZahlungBIC AS STRING, stZahlungEmpfaenger AS STRING, stZahlungNotiz AS STRING, stRStellHRAEintragID AS STRING
	DIM stRStellHRAEintragForm AS STRING, stRStellKonName AS STRING, stRStellKonEMail AS STRING, stRStellKonTel AS STRING, stKaufID AS STRING, stKaufName AS STRING, stKaufStr AS STRING
	DIM stKaufPlz AS STRING, stKaufStadt AS STRING, stKaufLandCode AS STRING, stKaufEMail AS STRING, stRDatum AS STRING, stRZahlungBisDatum AS STRING, stRKaufRef AS STRING, stRNummer AS STRING
	DIM stInvoiceTypeCode AS STRING, stDocumentCurrencyCode AS STRING, stCountryIdentificationCode AS STRING, stPaymentMeansCode AS STRING, stKaufUST_IdNr As String
	DIM stFileUrl AS STRING, stString AS STRING, stDataAmountTotal AS STRING, stAllowanceTotalAmount AS STRING, stChargeTotalAmount AS STRING, stKaufCompID AS STRING
	DIM stLDatum AS STRING, stLFirma AS STRING, stLStr AS STRING, stLPlz AS STRING, stLStadt AS STRING, stLLandCode AS STRING, stLAddress AS STRING, stDelivery AS STRING
	DIM stGlaeubID AS STRING, stIBANEmpfaenger AS STRING, stMandatID AS STRING, stSteuerfreiheit AS STRING, stRStellSteuerNr AS STRING, stPurchaseID As String, stSalesID As String
	DIM stTenderID AS STRING, stObjectID AS STRING, stAccounting AS STRING, stSellerID AS STRING, stSellerICDCode AS STRING, stProjectID As String, stContractID As String
	Dim stKaufAnsprechP As String, stKaufAnsprechPTel As String, stKaufAnsprechPEMail As String, stRStartDate As String, stREndDate As String, stRAnmerkung As String
	Dim stVorRechnungID As String, stPrepaidAmount As String, stPayableAmount As String

	DIM inTab AS INTEGER, inI AS INTEGER, i AS INTEGER, inAttach AS Integer, t As Integer
	DIM doDataAmountTotal AS DOUBLE, doAllowanceTotalAmount AS DOUBLE, doChargeTotalAmount AS DOUBLE
	DIM arDataID(), arDataDescription(), arDataName(), arDataQuantity(), arDataPrice(), arDataRabatt(), arDataAmount(), arDataTax(), arDataTaxID (), arDataQuantityUnitCode(), arDataSellID()
	DIM arDataStartDate(), arDataEndDate(), arDataRow(), arDataKonto(), arDataRabattIndicator(), arAllowanceChargeBaseAmount(), arAllowanceChargeTaxID()
	DIM arAllowanceChargeReason(), arAllowanceChargeAmount(), arAllowanceChargeTax(), arAllowanceChargeIndicator(), arAllowanceChargePercent()
	Dim arTaxPercent(0), arTaxNetto(0), arTaxTax(0), arTaxID(0)
	DIM arAttachFilename(), arAttachDescription(), arAttachMimeCode(), arAttachFile(), arVor(), arDocRefID(), arDocRefDate()

	REM Zuerst werden durch Ansichten und Abfragen veränderbare Daten aufgeführt.
	REM Anschließend kommen einige zentrale Variablen hinzu, die zur Zeit nicht aus der Datenbank bestückt werden.
	REM Die zentralen Variablen sind: Währung (EUR), Land des Rechnungsstellers (DE), Rechnungstyp (Handelrechnung, Code 380), Zahlungscode (IBAN innerhalb SEPA-Raum, Code 58)

	If iDocTypID = 5 Then
		if iOption_AZ = 1 then
			sPraefix=&quot;AZ&quot;
		else
			sPraefix=&quot;RE&quot;
		End if
		sInvoiceTypeCode=&quot;t3.RechnungsTypCodeID&quot;
	Elseif iDocTypID = 6 then
		sPraefix=&quot;GU&quot;
		sInvoiceTypeCode=&quot;&apos;381&apos;&quot;
	End If

	sSQL2=&quot;SELECT DISTINCT &quot;&amp;_
		&quot;TRIM(CONCAT(t4.Name1,&apos; &apos;,t4.Name2,&apos; &apos;,t4.Name3,&apos; &apos;,t4.Name4)) AS stRStellFirma_1,&quot;&amp;_
		&quot;TRIM(CONCAT(t4.Strasse,&apos; &apos;,t4.Hausnummer)) AS stRStellStr_2,t4.PLZ AS stRStellPlz_3,t4.Ort AS stRStellStadt_4,&quot;&amp;_
		&quot;t4.EMail AS stRStellEMail_5,t4.Url AS stRStellUrl_6,t4.Telefon AS stRStellTel_7,&quot;&amp;_
		&quot;t4.UmsatzsteuerID AS stRStellUST_IdNr_8,TRIM(CONCAT(t4.Name1,&apos; &apos;,t4.Name2,&apos; &apos;,t4.Name3,&apos; &apos;,t4.Name4)) AS stRStellAbwHandelsname_9,&quot;&amp;_
		&quot;t4.Bank AS stZahlungBank_10,t4.IBAN AS stZahlungIBAN_11,t4.BIC AS stZahlungBIC_12,&quot;&amp;_
		&quot;t4.Name1 AS stZahlungEmpfaenger_13,t4.HRB AS stRStellHRAEintragID_14,&quot;&amp;_
		&quot;(CASE WHEN t4.OptionInhaber=0 THEN &quot;&amp;_
			&quot;TRIM(CONCAT(&apos;Sitz der Gesellschaft: &apos;,t4.Ort,&apos;, Registergericht: &apos;,t4.Amtsgericht,&apos;, Geschäftsführer: &apos;,t4.Geschaeftsfuehrer)) &quot;&amp;_
		&quot;END) AS stRStellHRAEintragForm_15,&quot;&amp;_
		&quot;NULL AS NULL_16,NULL AS stZahlungNotiz_17,NULL AS stRStellKonName_18,NULL AS stRStellKonEMail_19,NULL AS stRStellKonTel_20,&quot;&amp;_
		&quot;t1.KontaktID AS stKaufID_21,TRIM(CONCAT(t1.Vorname,&apos; &apos;,t1.Name1,&apos; &apos;,t1.Name2,&apos; &apos;,t1.Name3,&apos; &apos;,t1.Name4)) AS stKaufName_22,&quot;&amp;_
		&quot;TRIM(CONCAT(t2.Vorname,&apos; &apos;,t2.Name)) AS stKaufAnsprechP_23,NULL AS NULL_24,TRIM(CONCAT(t1.Strasse,&apos; &apos;,t1.Hausnummer)) AS stKaufStr_25,&quot;&amp;_
		&quot;t1.PLZ AS stKaufPlz_26,t1.Ort AS stKaufStadt_27,UPPER(SUBSTRING(t1.Land,1,2)) AS stKaufLandCode_28,&quot;&amp;_
		&quot;t1.EMail AS stKaufEMail_29,NULL AS NULL_30,NULL AS NULL_31,NULL AS NULL_32,t3.Erstellungsdatum AS stRDatum_33,t3.gueltig_bis AS stRZahlungBisDatum_34,&quot;&amp;_
		&quot;t3.KontaktID AS stRKaufRef_35,CONCAT(&apos;&quot;&amp; sPraefix &amp;&quot; &apos;,t3.DocumentID) AS stRNummer_36,t1.UmsatzsteuerID AS stKaufUST_IdNr_37,&quot;&amp;_
		sInvoiceTypeCode &amp;&quot; AS stInvoiceTypeCode_38,t3.Erstellungsdatum AS stLDatum_39,NULL AS stLFirma_40,NULL AS stLStr_41,NULL AS stLPlz_42,NULL AS stLStadt_43,&quot;&amp;_
		&quot;NULL AS stLLandCode_44,NULL AS stRStartDate_45,NULL AS stREndDate_46,NULL AS stProjectID_47,NULL AS stContractID_48,&quot;&amp;_
		&quot;NULL AS stPurchaseID_49,NULL AS stSalesID_50,&quot;&amp;_
		&quot;(CASE WHEN &quot;&amp; sInvoiceTypeCode &amp;&quot;=384 AND t3.DocumentID_Korrekturrechnung&gt;0 THEN t3.DocumentID_Korrekturrechnung END) AS stVorRechnungID_51,&quot;&amp;_
		&quot;NULL AS stKaufCompID_52,&quot;&amp;_
		&quot;TRIM(CONCAT(&quot;&amp;_
			&quot;(CASE WHEN t3.ProjektID&gt;0 THEN CONCAT(t5.Projekt_Name,&apos;\n&apos;) ELSE &apos;&apos; END),&quot;&amp;_
			&quot;(CASE WHEN LENGTH(t3.Document_Name)&gt;0 THEN CONCAT(t3.Document_Name,&apos;\n\n&apos;) ELSE &apos;&apos; END),&quot;&amp;_
			&quot;(CASE WHEN &quot;&amp; sInvoiceTypeCode &amp;&quot;=384 AND t3.DocumentID_Korrekturrechnung&gt;0 THEN &quot;&amp;_
				&quot;CONCAT(&apos;Korrektur zu Rechnung &apos;,&quot;&amp;_
				&quot;(SELECT CONCAT(CASE WHEN AZ=1 THEN &apos;AZ&apos; ELSE &apos;RE&apos; END,&apos; &apos;,DocumentID) FROM &quot;&amp; sTabelle1 &amp;&quot; WHERE DocumentID=stVorRechnungID_51),&quot;&amp;_
				&quot;&apos; vom &apos;,DATE_FORMAT((SELECT Erstellungsdatum FROM &quot;&amp; sTabelle1 &amp;&quot; WHERE DocumentID=stVorRechnungID_51),&apos;%d.%m.%Y&apos;),&apos;\n\n&apos;) ELSE &apos;&apos; END),&quot;&amp;_
			&quot;(CASE WHEN LENGTH(t3.Leistungsempfaenger)&gt;0 THEN CONCAT(&apos;Leistungsempfänger:\n&apos;,t3.Leistungsempfaenger,&apos;\n\n&apos;) ELSE &apos;&apos; END),&quot;&amp;_
			&quot;(CASE WHEN LENGTH(t3.Lieferbemerkung)&gt;0 THEN CONCAT(t3.Lieferbemerkung,&apos;\n\n&apos;) ELSE &apos;&apos; END),&quot;&amp;_
			&quot;(CASE WHEN LENGTH(t3.Bemerkung)&gt;0 THEN CONCAT(t3.Bemerkung,&apos;\n\n&apos;) ELSE &apos;&apos; END))) AS stRAnmerkung_53,&quot;&amp;_
		&quot;NULL AS stGlaeubID_54,NULL AS stIBANEmpfaenger_55,NULL AS stMandatID_56,&quot;&amp;_
		&quot;(CASE WHEN t3.13b=1 THEN t3.13bText WHEN t3.USt_befreit=1 THEN t3.USt_befreit_Text ELSE NULL END) AS stSteuerfreiheit_57,&quot;&amp;_
		&quot;t4.Umsatzsteuernummer AS stRStellSteuerNr_58,NULL AS stTenderID_59,NULL AS stObjectID_60,NULL AS stAccounting_61,NULL AS stSellerID_62,&quot;&amp;_
		&quot;NULL AS stSellerICDCode_63,NULL AS stDocumentCurrencyCode_64,t2.Telefon AS stKaufAnsprechPTel_65,t2.EMail AS stKaufAnsprechPEMail_66,&quot;&amp;_
		&quot;(CASE WHEN t3.13b=1 THEN &apos;AE&apos; WHEN t3.USt_befreit=1 THEN &apos;E&apos; ELSE &apos;S&apos; END) AS arTaxID_67,t3.MwSt_Satz AS arTaxPercent_68,&quot;&amp;_
		&quot;t3.Rabatt_Satz AS arAllowanceChargePercent_69,&apos;Rabatt&apos; AS arAllowanceChargeReason_70,&apos;false&apos; AS arAllowanceChargeIndicator_71,&quot;&amp;_
		&quot;t3.Summe_ohne_MwSt AS arAllowanceChargeBaseAmount_72,t3.Rabatt AS arAllowanceChargeAmount_73,&quot;&amp;_
		&quot;t3.Korrektur_Satz AS arAllowanceChargePercent_74,t3.Korrektur_Anlass AS arAllowanceChargeReason_75,&quot;&amp;_
		&quot;(CASE WHEN t3.Korrektur_Vorzeichen=&apos;-&apos; THEN &apos;false&apos; ELSE &apos;true&apos; END) AS arAllowanceChargeIndicator_76,&quot;&amp;_
		&quot;t3.Summe_nach_Rabatt AS arAllowanceChargeBaseAmount_77,t3.Korrektur AS arAllowanceChargeAmount_78,&quot;&amp;_
		&quot;t3.Summe_nach_Korrektur AS arTaxNetto_79,t3.MwSt AS arTaxTax_80,t3.Summe_mit_MwSt AS stBrutto_81,t3.AZ_mit_MwSt AS stPrepaidAmount_82,&quot;&amp;_
		&quot;t3.Zahlbetrag_mit_MwSt AS stPayableAmount_83,t3.Skonto_Satz AS stSkontoSatz_84,t3.Skonto_Tage As stSkontoTage_85,&quot;&amp;_
		&quot;DATE_FORMAT(t3.Skonto_bis,&apos;%d.%m.%Y&apos;) AS stSkontoBis_86,t3.Skonto AS stSkonto_87,&quot;&amp;_
		&quot;(SELECT CONCAT(CASE WHEN AZ=1 THEN &apos;AZ&apos; ELSE &apos;RE&apos; END,&apos; &apos;,DocumentID) FROM &quot;&amp; sTabelle1 &amp;&quot; WHERE DocumentID=stVorRechnungID_51) AS stVorRechnungID_88,&quot;&amp;_
		&quot;(SELECT Erstellungsdatum FROM &quot;&amp; sTabelle1 &amp;&quot; WHERE DocumentID=stVorRechnungID_51) AS stVorRechnungDatum_89&quot;

	sSQL2=sSQL2 &amp;&quot; FROM &quot;&amp; sTabelle1 &amp;&quot; as t3 &quot;&amp;_
		&quot;LEFT OUTER JOIN &quot;&amp; sAnsprechpartner &amp;&quot; as t2 &quot;&amp;_
		&quot;ON t2.AnsprechpartnerID=t3.AnsprechpartnerID,&quot;&amp;_
		sKontakte &amp;&quot; as t1,&quot;&amp;_
		&quot;Einstellungen as t4,&quot;&amp;_
		sProjekte &amp;&quot; as t5&quot;&amp;_
		&quot; WHERE t3.DocumentID=&quot;&amp; lDocumentID &amp;_
		&quot; AND t1.KontaktID=t3.KontaktID&quot;&amp;_
		&quot; AND t4.EinstellungsID= &quot;&amp; iEinstellungsID_lokal &amp;_
		&quot; AND t5.ProjektID=t3.ProjektID&quot;

	oRecord2=oResult(sSql2)
	doAllowanceTotalAmount = 0
	doChargeTotalAmount = 0
	inI = 0
	
	REM Variablen, die über die Datenbank bestückt werden
	REM Spezifikation XRechnung mit Datentyp - [1]: genau einmal, Pflichteintrag; [0..1]: maximal einmal, kein Pflichteintrag
	REM Abfrage ergibt nur einen Datensatz. WHILE-Schleife eigentlich nicht notwendig
	WHILE oRecord2.Next		
		REM Das Wurzelelement INVOICE
		stRNummer = CharToXMLChar(oRecord2.getString(36))	&apos;Invoice number : Identifier [1]	[BT-1]
		stRDatum = oRecord2.getString(33)	&apos;Invoice issue date : Date [1]	[BT-2]
		stInvoiceTypeCode = oRecord2.getString(38)	&apos;Invoice type code : Code [1]	[BT-3]
		REM Ein Code, der den Funktionstyp der Rechnung angibt. Anmerkung: Der Rechnungstyp muss gemäß UNTDID 1001 spezifiziert werden.  
		REM Code ist auch als &quot;tbl_Rechnungstyp_Code&quot; der Datenbank beigefügt
		REM Folgende Codes aus der Codeliste sollen verwendet werden: 
		REM 326 (Partial invoice)		dt: Abschlagsrechnung
		REM 380 (Commercial invoice)	dt: Handelsrechnung
		REM 384 (Corrected invoice)		dt: korrigierte Rechnung
		REM 389 (Self-billed invoice)	dt: selbstfakturierte Rechnung (fakturieren → ausschreiben, also selbsterstellte Rechnung)
		REM 381 (Credit note)			dt: Gutschrift
		REM folgende Nummern für Bauvorhaben?
		REM 875 (Partial construction invoice)			dt: Teilbaurechnung
		REM 876 (Partial final construction invoice)	dt: Teilschlussrechnung Bau
		REM 877 (Final construction invoice)			dt: Baufertigstellungsrechnung
		REM Angebote haben nichts mit XRechnung zu tun.
		stDocumentCurrencyCode = oRecord2.getString(64)					&apos;Invoice currency code : Code [1] [BT-5]	
		IF stDocumentCurrencyCode = &quot;&quot; THEN stDocumentCurrencyCode = &quot;EUR&quot;	REM CurrencyCode nach CurrencyCode-2.4.gc, € gibt es da nicht
		stRZahlungBisDatum = oRecord2.getString(34)						&apos;Payment due date : Date [0..1]	[BT-9]
		stRKaufRef = CharToXMLChar(oRecord2.getString(35))				&apos;Buyer reference : Text [1]	[BT-10]	
		stProjectID = CharToXMLChar(oRecord2.getString(47))				&apos;Project reference : Document Reference [0..1] [BT-11]
		stContractID = CharToXMLChar(oRecord2.getString(48))			&apos;Contract reference : Document Reference [0..1] [BT-12]
		stPurchaseID = CharToXMLChar(oRecord2.getString(49))			&apos;Purchase order reference : Document Reference [0..1] [BT-13]
		stSalesID = CharToXMLChar(oRecord2.getString(50))				&apos;Sales order reference : Document Reference [0..1] [BT-14]
		IF stPurchaseID = &quot;&quot; AND stSalesID &lt;&gt; &quot;&quot; THEN stPurchaseID = &quot;NA&quot;	&apos;Angabe notwenig
		stTenderID = CharToXMLChar(oRecord2.getString(59))				&apos;Tender or lot reference : Document Reference [0..1] [BT-17]
		stObjectID = CharToXMLChar(oRecord2.getString(60))				&apos;Invoiced object identifier : Identifier [0..1] [BT-18]
		stAccounting = CharToXMLChar(oRecord2.getString(61))			&apos;Buyer accounting reference : Text [0..1] [BT-19]
		
		REM Bezahlung
		REM Gruppe CREDIT TRANSFER	[0..n]	[BG-17]
		stZahlungIBAN = oRecord2.getString(11)							&apos;Payment account identifier : Identifier [1]	[BT-84]
		stZahlungBIC = oRecord2.getString(12)							&apos;Payment service provider identifier : Identifier [0..1]	[BT-86]
		stZahlungEmpfaenger = CharToXMLChar(oRecord2.getString(13))		&apos;Payment account name : Text [0..1]	[BT-85]
		stZahlungNotiz = CharToXMLChar(oRecord2.getString(17))			&apos;Payment terms:	Text [0..1]	[BT-20]
		
		REM RechnungsstellerIn	
		REM Gruppe SELLER	[1]	[BG-4]
		stRStellFirma = CharToXMLChar(oRecord2.getString(1))			&apos;Seller trading name : Text [0..1]	[BT-28]
		stRStellEMail = CharToXMLChar(oRecord2.getString(5))			&apos;Seller electronic address : Identifier [1]	[BT-34]
		stRStellUST_IdNr =  CharToXMLChar(oRecord2.getString(8))		&apos;Seller VAT identifier : Identifier [0..1]	[BT-31]
		stRStellSteuerNr = CharToXMLChar(oRecord2.getString(58))		&apos;Seller tax registration identifier : Identifier [0..1] [BT-32]
		stRStellAbwHandelsname = CharToXMLChar(oRecord2.getString(9))	&apos;Seller name : Text [1]	[BT-27]
		REM Handelsregistereinträge
		stRStellHRAEintragID = CharToXMLChar(oRecord2.getString(14))	&apos;Seller legal registration identifier : Identifier [0..1]	[BT-30]
		stRStellHRAEintragForm = CharToXMLChar(oRecord2.getString(15))	&apos;Seller additional legal information : Text [0..1]	[BT-33]
		REM Gruppe SELLER → SELLER POSTAL ADDRESS	[1]	[BG-5]	
		stRStellStr = CharToXMLChar(oRecord2.getString(2))				&apos;Seller address line 1 : Text [0..1]	[BT-35]	
		stRStellPlz = CharToXMLChar(oRecord2.getString(3))				&apos;Seller post code : Text [1]	[BT-38]
		stRStellStadt = CharToXMLChar(oRecord2.getString(4))			&apos;Seller city : Text [1]	[BT-37]
		stRStellTel =  CharToXMLChar(oRecord2.getString(7))				&apos;ggf. Ersatz für Seller contact telephone number : Text [1]	[BT-42]
		REM RechnungsstellerMitarbeiter
		REM Gruppe SELLER → SELLER CONTACT [1] [BG-6]
		stRStellKonName = CharToXMLChar(oRecord2.getString(18))
		IF stRStellKonName = &quot;&quot; THEN stRStellKonName = stRStellFirma 	&apos;Seller contact point : Text [1] [BT-41]
		stRStellKonEMail = CharToXMLChar(oRecord2.getString(19))		
		IF stRStellKonEMail = &quot;&quot; THEN stRStellKonEMail = stRStellEMail	&apos;Seller contact email address : Text [1] [BT-43]
		stRStellKonTel = CharToXMLChar(oRecord2.getString(20))		
		IF stRStellKonTel = &quot;&quot; THEN stRStellKonTel = stRStellTel		&apos;Seller contact telephone number : Text [1]	[BT-42]
		stSellerID = CharToXMLChar(oRecord2.getString(62))				&apos;Seller identifier : Identifier [0..*] [BT-29]
		stSellerICDCode = oRecord2.getString(63)
		
		REM KäuferIn
		REM Gruppe BUYER [1] [BG-7]
		stKaufID = CharToXMLChar(oRecord2.getString(21))				&apos;Buyer identifier : Identifier [0..1] [BT-46]
		stKaufName = CharToXMLChar(oRecord2.getString(22))				&apos;Buyer name : Text [1] [BT-44]
		IF stKaufName = &quot;&quot; THEN stKaufName = CharToXMLChar(oRecord2.getString(23))	&apos;Buyer name : Text [1] [BT-44]
		stKaufCompID = oRecord2.getString(52)							&apos;Buyer legal registration identifier : Identifier [0..1] [BT-47]
		stKaufEMail = CharToXMLChar(oRecord2.getString(29))				&apos;Buyer electronic address : Identifier [1] [BT-49]
		stKaufUST_IdNr = CharToXMLChar(oRecord2.getString(37))			&apos;Buyer VAT identifier : Identifier [0..1] [BT-48]
		REM Gruppe BUYER → BUYER POSTAL ADDRESS : BUYER POSTAL ADDRESS [1]	[BG-8]
		stKaufStr = CharToXMLChar(oRecord2.getString(25))				&apos;Buyer address line 1 : Text [0..1]	[BT-50]
		stKaufPlz = CharToXMLChar(oRecord2.getString(26))				&apos;Buyer post code : Text [1]	[BT-53]
		stKaufStadt = CharToXMLChar(oRecord2.getString(27))				&apos;Buyer city : Text [1]	[BT-52]
		stKaufLandCode = oRecord2.getString(28)							&apos;Buyer country code : Code [1]	[BT-55]
		&apos;DE - Deutschland, NL - Niederlande, LU - Luxemburg, FR - Frankreich, CH - Schweiz … (2 Buchstaben, groß geschrieben)
		REM Gruppe BUYER → BUYER CONTACT : BUYER CONTACT [0..1]	[BG-9]
		stKaufAnsprechP = CharToXMLChar(oRecord2.getString(23))			&apos;Buyer contact point : Text [0..1]	[BT-56]
		stKaufAnsprechPTel = CharToXMLChar(oRecord2.getString(65))		&apos;Buyer contact telephone number :  Text [0..1]	[BT-57]
		stKaufAnsprechPEMail = CharToXMLChar(oRecord2.getString(66))	&apos;Buyer contact email address : Text [0..1]	[BT-58]
		
		REM Guppe DELIVERY INFORMATION [0..1] [BG-13]
		stLDatum = oRecord2.getString(39)								&apos;Actual delivery date : Date [0..1]	[BT-72]
		stLFirma = CharToXMLChar(oRecord2.getString(40))				&apos;Deliver to party name : Text [0..1] [BT-70]
		REM Gruppe DELIVERY INFORMATION → DELIVER TO ADDRESS	[0..1] [BG-15] 
		stLStr = oRecord2.getString(41)									&apos;Deliver to address line 1 : Text [0..1] [BT-75]
		stLPlz = oRecord2.getString(42)									&apos;Deliver to post code : Text [1] [BT-78]
		stLStadt = oRecord2.getString(43)								&apos;Deliver to city : Text [1] [BT-77]
		stLLandCode = oRecord2.getString(44)							&apos;Deliver to country code : Code [1] [BT-80]
		stLAddress = stLPlz &amp; stLStadt &amp; stLLandCode					&apos;Nur wenn ein Adresseintrag vorhanden sind soll die Gruppe BG-15 übernommen werden
		stDelivery = stLDatum &amp; stLFirma &amp; stLAddress					&apos;Nur wenn ein Adresseintrag oder Datum oder Firma vorhanden sind soll die Gruppe BG-13 übernommen werden
		REM Gruppe DELIVERY INFORMATION → INVOICING PERIOD [0..1] [BG-14]
		stRStartDate = oRecord2.getString(45)							&apos;Invoicing period start date : Date [0..1] [BT-73]
		stREndDate = oRecord2.getString(46)								&apos;Invoicing period end date : Date [0..1] [BT-74]

		REM Gruppe INVOICE NOTE [0..*] [BG-1]
		stRAnmerkung = CharToXMLChar(oRecord2.getString(53))			&apos;Invoice note : Text [1] [BT-22]

		REM Gruppe PRECEDING INVOICE REFERENCE [0..*] [BG-3]
		stVorRechnungID = oRecord2.getString(51)
		
		REM Gruppe PAYMENT INSTRUCTIONS → DIRECT DEBIT [0..1] [BG-19]
		stGlaeubID = CharToXMLChar(oRecord2.getString(54))				&apos;Bank assigned creditor identifier : Identifier [1] [BT-90]
		stIBANEmpfaenger = CharToXMLChar(oRecord2.getString(55))		&apos;Debited account identifier : Identifier [1] [BT-91]
		stMandatID = CharToXMLChar(oRecord2.getString(56))				&apos;Mandate reference identifier : Identifier [1] [BT-89]
		
		REM Gruppe VAT BREAKDOWN [1..*] [BG-23]		
		stSteuerfreiheit = CharToXMLChar(oRecord2.getString(57))		&apos;VAT exemption reason text : Text [0..1] [BT-120]

		REM Eigene Abfrage-Daten ######################################################################################################################################
		REM ###########################################################################################################################################################

		REM Ermäßigungen und Aufschläge Auf Rechnungsebene
		REM Gruppe DOCUMENT LEVEL ALLOWANCES [0..*] [BG-20] und Gruppe DOCUMENT LEVEL CHARGES [0..*] [BG-21]
		REM	AllowanceChargeReasonCode nach https://www.xrepository.de/details/urn:xoev-de:kosit:codeliste:untdid.5189_3 (für Zulagen, Nachlässe)
		REM	AllowanceChargeReasonCode nach https://www.xrepository.de/details/urn:xoev-de:kosit:codeliste:untdid.7143_4 (für Gebühren)	
		REM Da die Unterscheidungen nicht automatisch gemacht werden können und der Code nicht erforderlich ist fehlt dieser Code in der XRechnung 

		If oRecord2.getLong(69) &gt; 0 Then
			ReDim Preserve arAllowanceChargePercent(inI)	&apos;Document level allowance percentage : Percentage [0..1] [BT-94]; Document level charge percentage : Percentage [0..1] [BT-101]
			ReDim Preserve arAllowanceChargeReason(inI)		&apos;Document level allowance reason : Text [0..1] [BT-97]; Document level charge reason : Text [0..1] [BT-104]
			ReDim Preserve arAllowanceChargeAmount(inI)		&apos;Document level allowance amount : Amount [1] [BT-92]; Document level charge amount : Amount [1] [BT-99]
			ReDim Preserve arAllowanceChargeBaseAmount(inI)	&apos;Document level allowance base amount : Amount [0..1] [BT-93]; Document level charge base amount : Amount [0..1] [BT-100]
			ReDim Preserve arAllowanceChargeTax(inI)		&apos;Document level allowance VAT rate : Percentage [0..1] [BT-96]; Document level charge VAT rate : Percentage [0..1] [BT-103]
			ReDim Preserve arAllowanceChargeIndicator(inI)	&apos;mit false (Nachlass) und true (Zuschlag) wird der Unterschied zwischen den Gruppen sichtbar
			ReDim Preserve arAllowanceChargeTaxID(inI)		&apos;Document level allowance VAT category code : Code [1] [BT-95]; Document level charge VAT category code : Code [1] [BT-102]
			arAllowanceChargePercent(inI)=oRecord2.getLong(69) 		&apos;Rabatt-Satz
			arAllowanceChargeReason(inI)=oRecord2.getString(70) 	&apos;Abzug Grund: Rabatt
			arAllowanceChargeIndicator(inI)=oRecord2.getString(71)	&apos;Indikator: bei Rabatt false
			arAllowanceChargeBaseAmount(inI)=oRecord2.getString(72)	&apos;Rabatt von Betrag
			arAllowanceChargeAmount(inI)=oRecord2.getString(73)		&apos;Rabatt
			arAllowanceChargeTax(inI)=oRecord2.getLong(68)			&apos;MwSt-Satz
			arAllowanceChargeTaxID(inI)=oRecord2.getString(67)		&apos;USt Code ID
			IF arAllowanceChargeIndicator(inI) = &quot;true&quot; Then
				doChargeTotalAmount = doChargeTotalAmount + oRecord2.getDouble(73)
			ELSE
				doAllowanceTotalAmount = doAllowanceTotalAmount + oRecord2.getDouble(73)
			END IF
			inI=inI+1
		End If
		If oRecord2.getLong(74) &gt; 0 Then
			ReDim Preserve arAllowanceChargePercent(inI)	&apos;Document level allowance percentage : Percentage [0..1] [BT-94]; Document level charge percentage : Percentage [0..1] [BT-101]
			ReDim Preserve arAllowanceChargeReason(inI)		&apos;Document level allowance reason : Text [0..1] [BT-97]; Document level charge reason : Text [0..1] [BT-104]
			ReDim Preserve arAllowanceChargeAmount(inI)		&apos;Document level allowance amount : Amount [1] [BT-92]; Document level charge amount : Amount [1] [BT-99]
			ReDim Preserve arAllowanceChargeBaseAmount(inI)	&apos;Document level allowance base amount : Amount [0..1] [BT-93]; Document level charge base amount : Amount [0..1] [BT-100]
			ReDim Preserve arAllowanceChargeTax(inI)		&apos;Document level allowance VAT rate : Percentage [0..1] [BT-96]; Document level charge VAT rate : Percentage [0..1] [BT-103]
			ReDim Preserve arAllowanceChargeIndicator(inI)	&apos;mit false (Nachlass) und true (Zuschlag) wird der Unterschied zwischen den Gruppen sichtbar
			ReDim Preserve arAllowanceChargeTaxID(inI)		&apos;Document level allowance VAT category code : Code [1] [BT-95]; Document level charge VAT category code : Code [1] [BT-102]
			arAllowanceChargePercent(inI)=oRecord2.getLong(74) 		&apos;Korrektur-Satz
			arAllowanceChargeReason(inI)=oRecord2.getString(75) 	&apos;Korrektur Grund: z.B. Lieferaufschlag
			arAllowanceChargeIndicator(inI)=oRecord2.getString(76)	&apos;Indikator: bei Abzug false bei Aufschlag true
			arAllowanceChargeBaseAmount(inI)=oRecord2.getString(77)	&apos;Korrektur von Betrag
			arAllowanceChargeAmount(inI)=oRecord2.getString(78)		&apos;Korrektur
			arAllowanceChargeTax(inI)=oRecord2.getLong(68)			&apos;MwSt-Satz
			arAllowanceChargeTaxID(inI)=oRecord2.getString(67)		&apos;USt Code ID
			IF arAllowanceChargeIndicator(inI) = &quot;true&quot; Then
				doChargeTotalAmount = doChargeTotalAmount + oRecord2.getDouble(78)
			ELSE
				doAllowanceTotalAmount = doAllowanceTotalAmount + oRecord2.getDouble(78)
			END IF
		End If
		
		REM Gruppe VAT BREAKDOWN [1..*] [BG-23]
		REM TAX, ist auch als &quot;tbl_Steuer_Code&quot; der Datenbank beigefügt
		REM ID:
		REM S (Standard rate)			dt: Normaler Steuersatz
		REM Z (Zero rated goods)		dt: nicht besteuerte Waren
		REM E (Exempt from tax)			dt: steuerfrei
		REM AE (VAT Reverse Charge)		dt: Mehrwertsteuer (Umkehrung der Steuerschuldnerschaft)
		REM K (VAT exempt for EEA intra-community supply of goods and services)	dt: Mehrwertsteuerbefreiung für innergemeinschaftliche Lieferungen von Gegenständen und Dienstleistungen im EWR
		REM G (Free export item, tax not charged)	dt: Freier Ausfuhrartikel, keine Steuer
		REM O (Services outside scope of tax)		dt: Dienstleistungen außerhalb des Steuerbereichs
		REM L (Canary Islands general indirect tax)	dt: Allgemeine indirekte Steuer der Kanarischen Inseln
		REM M (Tax for production, services and importation in Ceuta and Melilla)	dt: Steuer auf Produktion, Dienstleistungen und Einfuhren in Ceuta und Melilla

		arTaxID(0) = oRecord2.getString(67)				&apos;VAT category code : Code [1] [BT-118]
		arTaxPercent(0) = oRecord2.getString(68)		&apos;VAT category rate : Percentage [1] [BT-119]
		arTaxNetto(0) = Round2Decimalplaces(oRecord2.getDouble(79))			&apos;VAT category taxable amount : Amount [1] [BT-116]
		arTaxTax(0) = Round2Decimalplaces(oRecord2.getDouble(80))			&apos;VAT category tax amount : Amount [1] [BT-117]
		
		REM SummeTotal
		REM Gruppe DOCUMENT TOTALS [1] [BG-22]	

		stNetto = Round2Decimalplaces(oRecord2.getDouble(79))				&apos;Invoice total amount without VAT : Amount [1] [BT-109]
		stSteuer = Round2Decimalplaces(oRecord2.getDouble(80))				&apos;Invoice total VAT amount : Amount [0..1] [BT-110]
		stBrutto = Round2Decimalplaces(oRecord2.getDouble(81))				&apos;Invoice total amount with VAT : Amount [1] [BT-112]
		stPrepaidAmount = Round2Decimalplaces(oRecord2.getDouble(82))		&apos;Paid amount : Amount [0..1] [BT-113]
		stPayableAmount = Round2Decimalplaces(oRecord2.getDouble(83))		&apos;Amount due for payment : Amount [1] [BT-115]

		stSkontoSatz = oRecord2.getString(84) &amp; 0
		stSkontoTage = oRecord2.getString(85)
		stSkontoBis = oRecord2.getString(86)
		stSkonto = oRecord2.getString(87)
		If oRecord2.getString(88) &lt;&gt; &quot;&quot; Then
			ReDim Preserve arDocRefID(0)
			ReDim Preserve arDocRefDate(0)
			arDocRefID(0) = oRecord2.getString(88)
			arDocRefDate(0) = oRecord2.getString(89)
		End If
		
	Wend
	REM Dummy für die Identifikation, falls BT-29, BT-30 und BT-31 leer sind
	IF stSellerID = &quot;&quot; AND stRStellHRAEintragID = &quot;&quot; AND stRStellUST_IdNr = &quot;&quot; THEN
		stSellerID = stRStellAbwHandelsname
	END IF
	REM Gruppe PAYMENT INSTRUCTIONS [1] [BG-16]
	stPaymentMeansCode = &quot;58&quot;	&apos;Payment means type code : Code [1] [BT-81]
	REM 58: Code, wenn nur IBAN (innerhalb des SEPA-Raumes) erforderlich ist
	REM 30: Code, wenn die BIC (außerhalb des SEPA-Raumes) erforderlich ist
	REM 58: SEPA credit transfer - Credit transfer inside the Single Euro Payment Area (SEPA) system.
	REM 59: SEPA direct debit - Direct debit inside the Single Euro Payment Area (SEPA) system.
	IF stIBANEmpfaenger &lt;&gt; &quot;&quot; THEN stPaymentMeansCode = &quot;59&quot;


	REM Gruppe INVOICE LINE [1..*] [BG-25]
	REM Vorletzter Eintrag ist die Tax-ID, Code siehe unten
	REM UnitCode siehe https://docs.peppol.eu/poacc/billing/3.0/codelist/UNECERec20/
	REM XPP für Stück, DAY für Tage, HUR für Stunden, MON für Monat	
	REM Wenn statt &quot;Rabatt&quot; mit &quot;Zuschlag&quot; gearbeitet werden soll, dann muss hier &quot;&quot;Rabatt&quot;&quot; &gt; 0 statt &quot;&quot;Rabatt&quot;&quot; &lt; 0 gesetzt werden.	

	sSQL3=&quot;SELECT DISTINCT t1.Pos AS arDataID_1,t1.Menge AS arDataQuantity_2,t1.Leistungsbeschreibung AS arDataDescription_3,&quot;&amp;_
		&quot;t1.EP AS arDataPrice_4,&apos;0&apos; AS arDataRabatt_5,&quot;&amp;_
		&quot;(CASE WHEN t1.Pos_TypID=1 THEN t1.GP ELSE 0 END) AS arDataAmount_6,&quot;&amp;_
		&quot;t2.MwSt_Satz AS arDataTax_7,&apos;&quot;&amp; arTaxID(0) &amp;&quot;&apos; AS arDataTaxID_8,t3.Code AS arDataQuantityUnitCode_9,NULL AS arDataStartDate_10,NULL AS arDataEndDate_11,&quot;&amp;_
		&quot;&apos;Main&apos; AS arDataRow_12,t1.Pos_TypID AS iPosTypID_13,NULL AS arDataKonto_14,COALESCE(t1.LeistungsID,t1.Pos) AS arDataSellID_15,NULL AS arDataRabattIndicator_16,&quot;&amp;_
		&quot;(CASE WHEN t1.Pos_TypID=1 OR t1.Pos_TypID=4 THEN t1.Leistungsbezeichnung ELSE TRIM(CONCAT(t4.Pos_Typ,&apos;\n&apos;,t1.Leistungsbezeichnung)) END) AS arDataName_17,&quot;&amp;_
		&quot;t1.Leistung AS arrDataLeistung_18,t1.Lieferung AS arrDataLieferung_19,t1.LeistungsID AS arDocRefID_20,t1.Bestellnummer AS arDocRefDate_21&quot;&amp;_
		&quot; FROM &quot;&amp; sArbeitstabelle &amp;&quot; AS t1 LEFT OUTER JOIN Einheit AS t3 ON t3.Einheit LIKE t1.Einheit,&quot;&amp; sTabelle1 &amp;&quot; AS t2,Pos_Typ AS t4&quot;&amp;_
		&quot; WHERE t2.DocumentID=t1.DocumentID&quot;&amp;_
		&quot; AND t4.Pos_TypID=t1.Pos_TypID&quot;&amp;_
		&quot; ORDER BY Pos ASC&quot;

	oRecord3=oResult_Scroll(sSql3)

	inI = 0
	i = UBOUND(arDocRefID())+1
	doDataAmountTotal = 0
	WHILE oRecord3.Next
		If oRecord3.getInt(13) &lt; 4 Then
			ReDim Preserve arDataID(inI)				&apos;Invoice line identifier : Identifier [1] [BT-126]
			ReDim Preserve arDataQuantity(inI)			&apos;Invoiced quantity : Quantity [1] [BT-129]
			ReDim Preserve arDataDescription(inI)		&apos;Invoice line note : Text [0..1] [BT-127]
			ReDim Preserve arDataName(inI)				&apos;Invoice line object identifier : Identifier [0..1] [BT-128]
			ReDim Preserve arDataAmount(inI)			&apos;Invoice line net amount : Amount [1] [BT-131]
			ReDim Preserve arDataQuantityUnitCode(inI)	&apos;Invoiced quantity unit of measure code : Code [1] [BT-130]
			ReDim Preserve arDataKonto(inI)				&apos;Invoice line Buyer accounting reference : Text [0..1] [BT-133]
			REM Gruppe INVOICE LINE → ITEM INFORMATION  [1] [BG-31]
			ReDim Preserve arDataSellID(inI) 			&apos;Item Sellers identifier : Identifier [0..1] [BT-155]
			REM Gruppe INVOICE LINE → INVOICE LINE ALLOWANCES [0..1] [BG-27]
			ReDim Preserve arDataRabatt(inI)			&apos;Invoice line allowance amount : Amount [1] [BT-136]		
			ReDim Preserve arDataRabattIndicator(inI)
			REM Gruppe INVOICE LINE → INVOICE LINE PERIOD [0..1] [BG-26]	
			ReDim Preserve arDataStartDate(inI)			&apos;Invoice line period start date : Date [0..1] [BT-134]
			ReDim Preserve arDataEndDate(inI)			&apos;Invoice line period end date : Date [0..1] [BT-135]
			REM Gruppe INVOICE LINE → LINE VAT INFORMATION [1] [BG-30]	
			ReDim Preserve arDataTax(inI)				&apos;Invoiced item VAT rate : Percentage [0..1] [BT-152]
			ReDim Preserve arDataTaxID(inI)				&apos;Invoiced item VAT category code : Code [1] [BT-151]
			REM Gruppe INVOICE LINE → PRICE DETAILS [1] [BG-29]
			ReDim Preserve arDataPrice(inI)				&apos;Item net price : Unit Price Amount [1] [BT-146]
			
			ReDim Preserve arDataRow(inI)
			arDataID(inI) = CharToXMLChar(oRecord3.getString(1))
			arDataQuantity(inI) = oRecord3.getString(2)
			arDataDescription(inI) = CharToXMLChar(oRecord3.getString(3))
	&apos;		ar() = Split(arDataDescription(inI),CHR(10))
	&apos;		arDataName(inI) = ar(0)	&apos;Item name : Text [1] [BT-153]
			arDataPrice(inI) = oRecord3.getString(4)
			arDataRabatt(inI) = Round2Decimalplaces(oRecord3.getDouble(5))	&apos;Rabatt wird hier nicht in Prozent sondern als absoluter Betrag ausgegeben; genau 2 Nachkommastellen
			arDataAmount(inI) = Round2Decimalplaces(oRecord3.getDouble(6))	&apos;genau 2 Nachkommastellen
			IF oRecord3.getInt(13) = 1 THEN doDataAmountTotal = doDataAmountTotal + oRecord3.getDouble(6)	&apos;genau 2 Nachkommastellen, nur MainSub 1 darf für den Gesamtbetrag der Rechnung herangezogen werden
			arDataTax(inI) = oRecord3.getString(7)
			arDataTaxID(inI) = oRecord3.getString(8)
			arDataQuantityUnitCode(inI) = oRecord3.getString(9)
			arDataStartDate(inI) = oRecord3.getString(10)
			arDataEndDate(inI) = oRecord3.getString(11)
			arDataRow(inI) = Trim(oRecord3.getString(12))	&apos;Main, MainSub (Übergang zu Sub) …			
			arDataKonto(inI) = CharToXMLChar(oRecord3.getString(14))	&apos;Invoice line Buyer accounting reference : Text [0..1] [BT-133]
			arDataSellID(inI) = CharToXMLChar(oRecord3.getString(15))	&apos;Item Sellers identifier : Identifier [0..1] [BT-155]
			arDataRabattIndicator(inI) = Trim(oRecord3.getString(16))
			arDataName(inI) = oRecord3.getString(17) &apos;Item name : Text [1] [BT-153]
			inI = inI + 1
		Else		&apos; hier kommmen die AZ&apos;s
&apos;Hier die AZ&apos;s angeben
	REM Gruppe PRECEDING INVOICE REFERENCE [0..*] [BG-3]
			If stZahlungNotiz &lt;&gt; &quot;&quot; Then 
				stZahlungNotiz = stZahlungNotiz &amp; Chr$(13)
			Else
				stZahlungNotiz = &quot;Vorhergehende Rechnungen zu dieser Rechnung: &quot; &amp; Chr$(13)
			End If
		
			ReDim Preserve arDocRefID(i)
			ReDim Preserve arDocRefDate(i)
			
			sAZ_Text=oRecord3.getString(17) &amp; &quot; ohne MwSt: &quot; &amp; oRecord3.getString(4) &amp; &quot; MwSt: &quot; &amp; oRecord3.getString(18) &amp;_
				&quot; MwSt-Satz: &quot; &amp; oRecord3.getString(19) &amp; &quot;% mit MwSt: &quot; &amp; oRecord3.getString(6)
			stZahlungNotiz = stZahlungNotiz &amp; CharToXMLChar(sAZ_Text)				&apos;Payment terms:	Text [0..1]	[BT-20]
			arDocRefID(i) = &quot;AZ &quot;&amp; oRecord3.getString(20)							&apos;Preceding Invoice reference : Document Reference [1] [BT-25]
			arDocRefDate(i) = oRecord3.getString(21)								&apos;Preceding Invoice issue date : Date [1..*] [BT-26]
			i = i + 1
		End If
	Wend
	
	REM Gruppe DOCUMENT TOTALS [1] [BG-22] (Kontrollwert aus den Einzelzeilen)
	stDataAmountTotal = Round2Decimalplaces(doDataAmountTotal)	&apos;Sum of Invoice line net amount : Amount [1] [BT-106]

	If stZahlungNotiz &lt;&gt; &quot;&quot; then
		stZahlungNotiz = stZahlungNotiz &amp; Chr$(13) &amp; Chr$(13)
	End if
	If CDbl(stSkontoSatz) &gt; 0 Then
		stZahlungNotiz = stZahlungNotiz &amp; &quot;Zahlbar bis zum &quot;&amp; stSkontoBis &amp;&quot; mit &quot;&amp; fZahlMitPunkt(stSkontoSatz) &amp;_
			&quot;% Skonto aus &quot;&amp; fTausenderpunkt(fZahlMitPunkt(stPayableAmount)) &amp;&quot; &quot;&amp; sWaehrung &amp;&quot; = &quot;&amp; fTausenderpunkt(fZahlMitPunkt(stSkonto)) &amp;&quot; &quot;&amp; sWaehrung &amp; Chr$(13) &amp;_
			&quot;sonst bis &quot;&amp; fConvDatum(stRZahlungBisDatum) &amp;&quot; ohne Abzug&quot; &amp; Chr$(13)
		stZahlungNotiz = stZahlungNotiz &amp; Chr$(13) &amp; &quot;#SKONTO#TAGE=&quot; &amp; stSkontoTage &amp; &quot;#PROZENT=&quot; &amp; stSkontoSatz &amp; &quot;#BASISBETRAG=&quot; &amp; stPayableAmount &amp; &quot;#&quot;
	Else
		stZahlungNotiz = stZahlungNotiz &amp; &quot;Zahlbar bis zum &quot;&amp; fConvDatum(stRZahlungBisDatum) &amp;&quot; ohne Abzug&quot;
	End If

	REM Gruppe DOCUMENT TOTALS [1] [BG-22] (Kontrollwert aus den Einzelzeilen)
	stAllowanceTotalAmount = Round2Decimalplaces(doAllowanceTotalAmount) &apos;genau 2 Nachkommastellen; Sum of allowances on document level : Amount [0..1] [BT-107]
	stChargeTotalAmount = Round2Decimalplaces(doChargeTotalAmount) &apos;genau 2 Nachkommastellen; Sum of charges on document level : Amount [0..1] [BT-108]

	inAttach = 0

	REM Weiter Variablen, die auf jeden Fall gesetzt werden müssen, aber (bisher) nicht von der Datenbank befüllt werden
	
	REM Gruppe SELLER → SELLER POSTAL ADDRESS	[1]	[BG-5]
	stCountryIdentificationCode = &quot;DE&quot;	&apos;Seller country code : Code [1] [BT-40]
	REM Als Code für das Land, aus dem die Rechnung kommt

	REM Tabulatoreinsprung als Anzahl an Leerzeichen festlegen
	inTab = 3
	
REM +++ Ab hier wird das Dokument zusammengestellt +++
	
	oUcb = createUnoService(&quot;com.sun.star.ucb.SimpleFileAccess&quot;)
	oOutputStream = createUnoService(&quot;com.sun.star.io.TextOutputStream&quot;)
	stFileUrl = stXRechnungPath
	IF oUcb.exists(stFileUrl) THEN
		oUcb.kill(stFileUrl)
	END IF
	oFile = oUcb.OpenFileReadWrite(stFileUrl)
	oOutputStream.SetOutputStream(oFile.getOutputStream)
	REM https://docs.oasis-open.org/ubl (Universal Business Language)
	REM https://docs.oasis-open.org/ubl/UBL-2.4.html vom 26.07.2023
	REM Übersicht der Einträge: https://docs.peppol.eu/poacc/billing/3.0/syntax/ubl-invoice/tree/
	REM Neben UBL ist noch das Format UN/CEFACT Cross Industry Invoice XML message as specified in XML Schemas 16B (SCRDM - CII) möglich.
	REM Der Sender muss eines dieser Formate einhalten. Der Empfänger muss beide Formate lesen können.
	REM In dem folgenden Code sind die jeweiligen Zeilen als erforderlich oder nicht erforderlich gekennzeichnet. 
	REM 1…1 bedeutet: 1 von 1 muss vorhanden sein
	REM 0…1 bedeutet: 0 von maximal 1 darf vorhanden sein
	REM 0…n bedeutet: 0 von belibig vielen darf vorhanden sein
	REM [BT-1] - Einzelnummer
	REM [BG-14] - Gruppennummer
	stString = &quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;UTF-8&quot;&quot;?&gt;&quot; &amp; CHR(13) &amp; _
		&quot;&lt;ubl:Invoice xmlns:ubl=&quot;&quot;urn:oasis:names:specification:ubl:schema:xsd:Invoice-2&quot;&quot;&quot; &amp; CHR(13) &amp; _
		Space(2 * inTab) &amp; &quot;xmlns:cac=&quot;&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2&quot;&quot;&quot; &amp; CHR(13) &amp; _
		Space(2 * inTab) &amp; &quot;xmlns:cbc=&quot;&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot;&quot;&quot; &amp; CHR(13) &amp; _
        Space(2 * inTab) &amp; &quot;xmlns:xsi=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot;&quot; &amp; CHR(13) &amp; _
        Space(2 * inTab) &amp; &quot;xsi:schemaLocation=&quot;&quot;urn:oasis:names:specification:ubl:schema:xsd:Invoice-2 http://docs.oasis-open.org/ubl/os-UBL-2.3/xsd/maindoc/UBL-Invoice-2.3.xsd&quot;&quot;&gt;&quot; &amp; CHR(13)
	REM Rechnung ist zu XRechnung 3.0 kompatible, Identifier Gruppe PROCESS CONTROL, erforderlich [BT-24]
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:CustomizationID&gt;urn:cen.eu:en16931:2017#compliant#urn:xeinkauf.de:kosit:xrechnung_3.0#conformant#urn:xeinkauf.de:kosit:extension:xrechnung_3.0&lt;/cbc:CustomizationID&gt;&quot; &amp; CHR(13)
	REM Default Value Gruppe PROCESS CONTROL, erforderlich [BT-23]
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:ProfileID&gt;urn:fdc:peppol.eu:2017:poacc:billing:01:1.0&lt;/cbc:ProfileID&gt;&quot; &amp; CHR(13)
	REM Einzelwerte aus der Datenbank
	REM ID → Rechnungsnummer, muss eindeutig sein, IssueDate → Rechnungsdatum (Ausstellungsdatum), DueDate → Fälligkeitsdatum des Rechnungsbetrages.
    stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stRNummer &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)					&apos;erforderlich 1…1	[BT-1]
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:IssueDate&gt;&quot; &amp; stRDatum &amp; &quot;&lt;/cbc:IssueDate&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-2]
	IF stRZahlungBisDatum &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:DueDate&gt;&quot; &amp; stRZahlungBisDatum &amp; &quot;&lt;/cbc:DueDate&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-9]
	END IF
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:InvoiceTypeCode&gt;&quot; &amp; stInvoiceTypeCode &amp; &quot;&lt;/cbc:InvoiceTypeCode&gt;&quot; &amp; CHR(13)		&apos;erforderlich 1…1	[BT-3]	
	IF stRAnmerkung &lt;&gt; &quot;&quot; Then
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:Note&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-22]
		stString = stString &amp; Trim(stRAnmerkung)
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cbc:Note&gt;&quot; &amp; CHR(13)
	END IF
    stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:DocumentCurrencyCode&gt;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&lt;/cbc:DocumentCurrencyCode&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-5]
    IF stAccounting &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:AccountingCost&gt;&quot; &amp; stAccounting &amp; &quot;&lt;/cbc:AccountingCost&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-19]
    END IF
    REM Die Leitweg-ID eines Rechnungsempfängers wird in der Regel im konkreten Auftrag an den Rechnungssteller bzw. Rechnungssender übermittelt.
    REM Alternativ zur BuyerReference kann eine &quot;Purchase order reference&quot; (Unterverzeichnis OrderReference → ID) genutzt werden.
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cbc:BuyerReference&gt;&quot; &amp; stRKaufRef &amp; &quot;&lt;/cbc:BuyerReference&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, alternativ erforderlich OrderReference → ID , hier könnte auch die LeitwegID (für Behörden) stehen [BT-10]
    REM Rechnungsweite Angabe von Startdatum und Enddatum
    IF stRStartDate &lt;&gt; &quot;&quot; OR stREndDate &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:InvoicePeriod&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-14]
		IF stRStartDate &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:StartDate&gt;&quot; &amp; stRStartDate &amp; &quot;&lt;/cbc:StartDate&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1	[BT-73]
		IF stREndDate &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:EndDate&gt;&quot; &amp; stREndDate &amp; &quot;&lt;/cbc:EndDate&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1	[BT-74]	
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:InvoicePeriod&gt;&quot; &amp; CHR(13)
	END IF
	REM Referenzen
    IF stPurchaseID &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:OrderReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stPurchaseID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1	[BT-13]
		IF stSalesID &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:SalesOrderID&gt;&quot; &amp; stSalesID &amp; &quot;&lt;/cbc:SalesOrderID&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1	[BT-14]	
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:OrderReference&gt;&quot; &amp; CHR(13)
	END IF 
	REM Möglichkeit zur Angabe von Rechnungsdokumenten, auf die sich das aktuelle Dokument bezieht (Teilrechnungen)
	IF UBOUND(arDocRefID()) &gt; -1 THEN
		FOR i = 0 TO UBOUND(arDocRefID())
			stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:BillingReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…n [BG-3]
			stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:InvoiceDocumentReference&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn BillingReference vorhanden ist
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arDocRefID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn BillingReference vorhanden ist	[BT-25]
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:IssueDate&gt;&quot; &amp; arDocRefDate(i) &amp; &quot;&lt;/cbc:IssueDate&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-26]
			stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:InvoiceDocumentReference&gt;&quot; &amp; CHR(13)
			stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:BillingReference&gt;&quot; &amp; CHR(13)
    	NEXT
    END IF	
      	
    IF stTenderID &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:OriginatorDocumentReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stTenderID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn OriginatorDocumentReference gegeben	[BT-17]	
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:OriginatorDocumentReference&gt;&quot; &amp; CHR(13)
	END IF	  	
    IF stContractID &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:ContractDocumentReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stContractID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn ContractDocumentReference gegeben	[BT-12]	
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:ContractDocumentReference&gt;&quot; &amp; CHR(13)
	END IF	
    REM Eingebettete Dokumente (statt Anhängen) in Base64-Code
    IF inAttach &gt; 0 THEN
    	FOR i = 0 TO UBOUND(arAttachFilename())
    		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:AdditionalDocumentReference&gt;&quot; &amp; CHR(13)				&apos;nicht erforderlich 0…n	[BG-24]
    		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot;+arAttachFilename(i)+&quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-18, BT-122]
    		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:DocumentDescription&gt;&quot;+arAttachDescription(i)+&quot;&lt;/cbc:DocumentDescription&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-123]
    		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:Attachment&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
    		REM Der Anhang kann entweder als Base64-Dokument eingebunden werden oder zusammen mit der Rechnung zugestellt werden.
    		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:EmbeddedDocumentBinaryObject mimeCode=&quot;&quot;&quot;+arAttachMimeCode(i)+&quot;&quot;&quot; filename=&quot;&quot;&quot;+arAttachFilename(i)+&quot;&quot;&quot;&gt;&quot;+arAttachFile(i)+&quot;&lt;/cbc:EmbeddedDocumentBinaryObject&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-125]
    		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:Attachment&gt;&quot; &amp; CHR(13)
  			stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:AdditionalDocumentReference&gt;&quot; &amp; CHR(13)
		NEXT
  	END IF
  	  	
    IF stObjectID &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:AdditionalDocumentReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stObjectID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn ContractDocumentReference gegeben	[BT-18]	
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:DocumentTypeCode&gt;130&lt;/cbc:DocumentTypeCode&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:AdditionalDocumentReference&gt;&quot; &amp; CHR(13)
	END IF    
    IF stProjectID &lt;&gt; &quot;&quot; THEN
    	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:ProjectReference&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	Achtung! ProjectReference muss als letzte vor AccountingSupplierParty stehen
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stProjectID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn ProjectReference gegeben		[BT-11]	
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:ProjectReference&gt;&quot; &amp; CHR(13)
	END IF
	
    REM AccountingSupplierParty - Verkäufer, hier der Rechnungssteller
    stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:AccountingSupplierParty&gt;&quot; &amp; CHR(13)		&apos;erforderlich 1…1	[BG-4]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:Party&gt;&quot; &amp; CHR(13)		&apos;erforderlich 1…1
    stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:EndpointID schemeID=&quot;&quot;EM&quot;&quot;&gt;&quot; &amp; stRStellEMail &amp; &quot;&lt;/cbc:EndpointID&gt;&quot; &amp; CHR(13)		&apos;erforderlich 1…1, mit entsprechender schemeID	[BT-34]
    IF stSellerID &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyIdentification&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&quot;
		IF stSellerICDCode &lt;&gt; &quot;&quot; THEN stString = stString &amp; &quot; schemeID=&quot;&quot;&quot; &amp; stSellerICDCode &amp; &quot;&quot;&quot;&quot; 
		stString = stString &amp; &quot;&gt;&quot; &amp; stSellerID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PartyIdentification vorhanden ist	[BT-29]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyIdentification&gt;&quot; &amp; CHR(13)
	END IF    
	IF stIBANEmpfaenger &lt;&gt; &quot;&quot; AND stMandatID &lt;&gt; &quot;&quot; AND stGlaeubID &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyIdentification&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID schemeID=&quot;&quot;SEPA&quot;&quot;&gt;&quot; &amp; stGlaeubID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PartyIdentification vorhanden ist	[BT-90]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyIdentification&gt;&quot; &amp; CHR(13)
	END IF
    stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 (für &quot;Seller trading name&quot;)
    stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; stRStellFirma &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PartyName vorhanden ist; abweichender Name der Firma, so etwas wie Rufname, Name, unter dem die Firma dem Kunden bekannt ist	[BT-28]
    stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyName&gt;&quot; &amp; CHR(13)
    stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PostalAddress&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-5]
    IF stRStellStr &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:StreetName&gt;&quot; &amp; stRStellStr &amp; &quot;&lt;/cbc:StreetName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-35]
    stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CityName&gt;&quot; &amp; stRStellStadt &amp; &quot;&lt;/cbc:CityName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 docs.peppol.eu, erforderlich 1…1 Standard XRechnung	[BT-37]
    stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:PostalZone&gt;&quot; &amp; stRStellPlz &amp; &quot;&lt;/cbc:PostalZone&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 docs.peppol.eu, erforderlich 1…1 Standard XRechnung	[BT-38]
    stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:Country&gt;&quot; &amp; CHR(13)
    stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:IdentificationCode&gt;&quot; &amp; stCountryIdentificationCode &amp; &quot;&lt;/cbc:IdentificationCode&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-40]
    stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:Country&gt;&quot; &amp; CHR(13)
    stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PostalAddress&gt;&quot; &amp; CHR(13)
    
    REM Einträge für die Steuer
    IF stRStellUST_IdNr &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…2, hier nur VAT abgefragt
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyID&gt;&quot; &amp; stRStellUST_IdNr &amp; &quot;&lt;/cbc:CompanyID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist [BT-31]
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist
		stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:ID&gt;VAT&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist Mandatory element. For Seller VAT identifier (BT-31), use value “VAT”, for the seller tax registration identifier (BT-32), use != &quot;VAT&quot;
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)
	END IF	
    IF stRStellSteuerNr &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…2, hier nur FC abgefragt
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyID&gt;&quot; &amp; stRStellSteuerNr &amp; &quot;&lt;/cbc:CompanyID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist [BT-32]
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist
		stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:ID&gt;FC&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist Mandatory element. For Seller VAT identifier (BT-31), use value “VAT”, for the seller tax registration identifier (BT-32), use != &quot;VAT&quot;
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)
	END IF
	
	Rem Handelsregistereinträge	
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyLegalEntity&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:RegistrationName&gt;&quot; &amp; stRStellAbwHandelsname &amp; &quot;&lt;/cbc:RegistrationName&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-27]
	IF stRStellHRAEintragID &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyID&gt;&quot; &amp; stRStellHRAEintragID &amp; &quot;&lt;/cbc:CompanyID&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-30]
	IF stRStellHRAEintragForm &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyLegalForm&gt;&quot; &amp; stRStellHRAEintragForm &amp; &quot;&lt;/cbc:CompanyLegalForm&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-33]
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyLegalEntity&gt;&quot; &amp; CHR(13)
    
    REM Kontakt über Telefon usw.
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:Contact&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 docs.peppol.eu, erforderlich 1…1 Standard XRechnung [BG-6]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; stRStellKonName &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 Standard XRechnung	[BT-41]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Telephone&gt;&quot; &amp; stRStellKonTel &amp; &quot;&lt;/cbc:Telephone&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 Standard XRechnung	[BT-42]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ElectronicMail&gt;&quot; &amp; stRStellKonEMail &amp; &quot;&lt;/cbc:ElectronicMail&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 Standard XRechnung	[BT-43]
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:Contact&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:Party&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:AccountingSupplierParty&gt;&quot; &amp; CHR(13)
    
    REM AccountingCustomerParty - Käufer    
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:AccountingCustomerParty&gt;&quot; &amp; CHR(13)		&apos;erforderlich 1…1	[BG-7]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:Party&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:EndpointID schemeID=&quot;&quot;EM&quot;&quot;&gt;&quot; &amp; stKaufEMail &amp; &quot;&lt;/cbc:EndpointID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-49]
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyIdentification&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stKaufID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PartyIdentification vorhanden ist	[BT-46]
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyIdentification&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PostalAddress&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-8]
	IF stKaufStr &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:StreetName&gt;&quot; &amp; stKaufStr &amp; &quot;&lt;/cbc:StreetName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-50]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CityName&gt;&quot; &amp; stKaufStadt &amp; &quot;&lt;/cbc:CityName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 docs.peppol.eu, erforderlich 1…1 Standard XRechnung	[BT-52]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:PostalZone&gt;&quot; &amp; stKaufPlz &amp; &quot;&lt;/cbc:PostalZone&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 docs.peppol.eu, erforderlich 1…1 Standard XRechnung	[BT-53]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:Country&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1
	stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:IdentificationCode&gt;&quot; &amp; stKaufLandCode &amp; &quot;&lt;/cbc:IdentificationCode&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-55]
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:Country&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PostalAddress&gt;&quot; &amp; CHR(13)
	REM Einträge für die Steuer - Käufer
    IF stKaufUST_IdNr &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyID&gt;&quot; &amp; stKaufUST_IdNr &amp; &quot;&lt;/cbc:CompanyID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist	[BT-48]
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist
		stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:ID&gt;VAT&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1, wenn PartyTaxScheme vorhanden ist grundsätzlich VAT!
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyTaxScheme&gt;&quot; &amp; CHR(13)
	END IF
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyLegalEntity&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1
	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:RegistrationName&gt;&quot; &amp; stKaufName &amp; &quot;&lt;/cbc:RegistrationName&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-44]
	IF stKaufCompID &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CompanyID&gt;&quot; &amp; stKaufCompID &amp; &quot;&lt;/cbc:CompanyID&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-47]
	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyLegalEntity&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	
	REM Ansprechpartner Kontakt über Telefon usw., nicht erforderlich	
	IF stKaufAnsprechP &lt;&gt; &quot;&quot; OR stKaufAnsprechPTel &lt;&gt; &quot;&quot; OR stKaufAnsprechPEMail &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:Contact&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich [BG-9]
		IF stKaufAnsprechP &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; stKaufAnsprechP &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-56]
		IF stKaufAnsprechPTel &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Telephone&gt;&quot; &amp; stKaufAnsprechPTel &amp; &quot;&lt;/cbc:Telephone&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-57]
		IF stKaufAnsprechPEMail &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ElectronicMail&gt;&quot; &amp; stKaufAnsprechPEMail &amp; &quot;&lt;/cbc:ElectronicMail&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-58]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:Contact&gt;&quot; &amp; CHR(13)
	END IF
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:Party&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:AccountingCustomerParty&gt;&quot; &amp; CHR(13)
	REM Einträge für die Zustellung
	IF stDelivery &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:Delivery&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-13]	
        IF stLDatum &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ActualDeliveryDate&gt;&quot; &amp; stLDatum &amp; &quot;&lt;/cbc:ActualDeliveryDate&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-72]
        IF stLAddress &lt;&gt; &quot;&quot; THEN
        	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:DeliveryLocation&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
        	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:Address&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-15]
			IF stLStr &lt;&gt; &quot;&quot; THEN stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:StreetName&gt;&quot; &amp; stLStr &amp; &quot;&lt;/cbc:StreetName&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-75]
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:CityName&gt;&quot; &amp; stLStadt &amp; &quot;&lt;/cbc:CityName&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 wenn Adresse angegeben	[BT-77]
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:PostalZone&gt;&quot; &amp; stLPlz &amp; &quot;&lt;/cbc:PostalZone&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 wenn Adresse angegeben	[BT-78]
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:Country&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
			stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:IdentificationCode&gt;&quot; &amp; stLLandCode &amp; &quot;&lt;/cbc:IdentificationCode&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 wenn Adresse angegeben	[BT-80]
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:Country&gt;&quot; &amp; CHR(13)
        	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:Address&gt;&quot; &amp; CHR(13)
        	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:DeliveryLocation&gt;&quot; &amp; CHR(13)
		END IF		
        IF stLFirma &lt;&gt; &quot;&quot; THEN
        	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:DeliveryParty&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
        	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PartyName&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 wenn DeliverParty gegeben
        	stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; stLFirma &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 wenn DeliverParty gegeben	[BT-70]
        	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PartyName&gt;&quot; &amp; CHR(13)
        	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:DeliveryParty&gt;&quot; &amp; CHR(13)
        END IF   
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:Delivery&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
    END IF
	
	REM PaymentMeans - Zahlungsmmöglichkeiten	
	REM Grundsätzlich sind hier mehrere Kontoangaben nacheinander möglich. Zusätzlich (hier nicht aufgeführt, gibt es so etwas wie Bankabbuchungen und PayPal.
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:PaymentMeans&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…n docs.peppol.eu, erforderlich 1…n Standard XRechnung	[BG-16]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:PaymentMeansCode&gt;&quot; &amp; stPaymentMeansCode &amp; &quot;&lt;/cbc:PaymentMeansCode&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PaymentMeans vorhanden ist	[BT-81]
	IF stZahlungIBAN &lt;&gt; &quot;&quot; AND stIBANEmpfaenger = &quot;&quot; THEN
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:PayeeFinancialAccount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-17]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stZahlungIBAN &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PayeeFinancialAccount vorhanden ist	[BT-84]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; stZahlungEmpfaenger &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-85]
		IF stPaymentMeansCode = &quot;30&quot; OR stZahlungBIC &lt;&gt; &quot;&quot;  THEN
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:FinancialInstitutionBranch&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stZahlungBIC &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn FinancialInstitutionBranch vorhanden ist	[BT-86]
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:FinancialInstitutionBranch&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		END IF
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:PayeeFinancialAccount&gt;&quot; &amp; CHR(13)
	END IF
	IF stIBANEmpfaenger &lt;&gt; &quot;&quot; AND stMandatID &lt;&gt; &quot;&quot; AND stGlaeubID &lt;&gt; &quot;&quot; THEN
		REM PaymentMeansCode hier 59
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:PaymentMandate&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-19]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stMandatID &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-89]	
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:PayerFinancialAccount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; stIBANEmpfaenger &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PayerFinancialAccount vorhanden ist	[BT-91]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:PayerFinancialAccount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:PaymentMandate&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
	END IF
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:PaymentMeans&gt;&quot; &amp; CHR(13)
    REM PaymentTerms - Zahlungsvereinbarungen
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:PaymentTerms&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:Note&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn PaymentTerms vorhanden ist [BT-20]
	stString = stString &amp; Trim(stZahlungNotiz) &amp; CHR(13)
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cbc:Note&gt;&quot; &amp; CHR(13)
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:PaymentTerms&gt;&quot; &amp; CHR(13)
	
	REM Möglichkeit zur Angabe von Versandkosten/Lieferkosten, muss aber auch als ChargeTotalAmount eingetragen werden
	FOR i = 0 TO UBOUND(arAllowanceChargeAmount())
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:AllowanceCharge&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…n	[BG-20, BG-21]
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ChargeIndicator&gt;&quot; &amp; arAllowanceChargeIndicator(i) &amp; &quot;&lt;/cbc:ChargeIndicator&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist; &quot;true&quot; für einen Aufschlag
	&apos;	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:AllowanceChargeReasonCode&gt;&quot; &amp; arAllowCode(i) &amp; &quot;&lt;/cbc:AllowanceChargeReasonCode&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Code unklar
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:AllowanceChargeReason&gt;&quot; &amp; arAllowanceChargeReason(i) &amp; &quot;&lt;/cbc:AllowanceChargeReason&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1 [BT-97, BT-104]
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:MultiplierFactorNumeric&gt;&quot; &amp; arAllowanceChargePercent(i) &amp; &quot;&lt;/cbc:MultiplierFactorNumeric&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-94,BT-101]
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:Amount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arAllowanceChargeAmount(i) &amp; &quot;&lt;/cbc:Amount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist	[BT-92,BT-99]
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:BaseAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arAllowanceChargeBaseAmount(i) &amp; &quot;&lt;/cbc:BaseAmount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 1…1 [BT-93,BT-100]
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:TaxCategory&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arAllowanceChargeTaxID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist; Bedeutung des Codes siehe weiter unten	[BT-95,BT-102]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:Percent&gt;&quot; &amp; arAllowanceChargeTax(i) &amp; &quot;&lt;/cbc:Percent&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Angabe in Prozent*100	[BT-96,BT-103]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&gt;VAT&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist; VAT: Value Added Tax → Mehrwertsteuer
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:TaxCategory&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:AllowanceCharge&gt;&quot; &amp; CHR(13)
    NEXT
    

	REM Steuer	
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:TaxTotal&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…2 (When tax currency code is provided, two instances of the tax total must be present, but only one with tax subtotal.) [BG-23]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:TaxAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stSteuer &amp; &quot;&lt;/cbc:TaxAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1; Gesamtsteuer	[BT-110, BT-111]
	FOR i = 0 TO UBOUND(arTaxPercent())
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:TaxSubtotal&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…n (When tax currency code is provided, two instances of the tax total must be present, but only one with tax subtotal.) [BG-23]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:TaxableAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arTaxNetto(i) &amp; &quot;&lt;/cbc:TaxableAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist; Einzelsteuern mit Steuersatz	[BT-116]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:TaxAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arTaxTax(i) &amp; &quot;&lt;/cbc:TaxAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist	[BT-117]
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:TaxCategory&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arTaxID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist	[BT-118]
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:Percent&gt;&quot; &amp; arTaxPercent(i) &amp; &quot;&lt;/cbc:Percent&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-119]
		IF stSteuerfreiheit &lt;&gt; &quot;&quot; THEN
			stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cbc:TaxExemptionReason&gt;&quot; &amp; stSteuerfreiheit &amp; &quot;&lt;/cbc:TaxExemptionReason&gt;&quot;  &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BT-120]
		END IF
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist
		stString = stString &amp; Space(5 * inTab) &amp; &quot;&lt;cbc:ID&gt;VAT&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn TaxSubtotal vorhanden ist; VAT: Value Added Tax → Mehrwertsteuer
		stString = stString &amp; Space(4 * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:TaxCategory&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:TaxSubtotal&gt;&quot; &amp; CHR(13)
	NEXT
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:TaxTotal&gt;&quot; &amp; CHR(13)
    REM Gesamtbetrag, Aufsummierung der Teilbeträge; Alle hier aufgeführten Beträge müssen auf die 2. Stelle nach dem Komma gerundet werden
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:LegalMonetaryTotal&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-22]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:LineExtensionAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stDataAmountTotal &amp; &quot;&lt;/cbc:LineExtensionAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1; genau 2 Nachkommastellen	[BT-106]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:TaxExclusiveAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stNetto &amp; &quot;&lt;/cbc:TaxExclusiveAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-109]
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:TaxInclusiveAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stBrutto &amp; &quot;&lt;/cbc:TaxInclusiveAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-112]
	IF doAllowanceTotalAmount &gt; 0 THEN
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:AllowanceTotalAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stAllowanceTotalAmount &amp; &quot;&lt;/cbc:AllowanceTotalAmount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Nachlassbetrag ohne Steuer	[BT-107]
	END IF	
	IF doChargeTotalAmount &lt;&gt; 0 THEN
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:ChargeTotalAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stChargeTotalAmount &amp; &quot;&lt;/cbc:ChargeTotalAmount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Zuschlag ohne Steuer	[BT-108]
	END IF	
	IF stPrepaidAmount &lt;&gt; &quot;&quot; THEN
		stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:PrepaidAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stPrepaidAmount &amp; &quot;&lt;/cbc:PrepaidAmount&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Zuschlag ohne Steuer	[BT-113]
	END IF
	stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cbc:PayableAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stPayableAmount &amp; &quot;&lt;/cbc:PayableAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1 [BT-115]
	stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:LegalMonetaryTotal&gt;&quot; &amp; CHR(13)
	REM Schleife für die einzelnen Einträge in der Rechnung (Rechnungszeile), Lieferkosten können hier ebenfalls erscheinen.
	REM Lieferkosten wären auch über einen separaten Eintrag für die Gesamtrechnung möglich
	FOR i = 0 TO UBOUND(arDataID())
		IF arDataRow(i) = &quot;Main&quot; OR arDataRow(i) = &quot;MainToSub&quot; THEN
			stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;cac:InvoiceLine&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…n	[BG-25]
			t = 0
		ELSEIF arDataRow(i) = &quot;Sub&quot; OR arDataRow(i) = &quot;SubToSubSub&quot; OR arDataRow(i) = &quot;SubToMain&quot; THEN
			stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;cac:SubInvoiceLine&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 1…n
			t = 1
		ELSEIF arDataRow(i) = &quot;SubSub&quot; OR arDataRow(i) = &quot;SubSubToSub&quot; OR arDataRow(i) = &quot;SubSubToMain&quot;	THEN		
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cac:SubInvoiceLine&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 1…n
			t = 2
		ELSE
		END If
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arDataID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-126]
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cbc:InvoicedQuantity unitCode=&quot;&quot;&quot; &amp; arDataQuantityUnitCode(i) &amp; &quot;&quot;&quot;&gt;&quot; &amp; arDataQuantity(i) &amp; &quot;&lt;/cbc:InvoicedQuantity&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-129]
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cbc:LineExtensionAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arDataAmount(i) &amp; &quot;&lt;/cbc:LineExtensionAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1; Gesamtpreis aus Price * Quantity * Allowance; genau 2 Nachkommastellen	[BT-131]
		IF arDataKonto(i) &lt;&gt; &quot;&quot; THEN
			stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cbc:AccountingCost&gt;&quot; &amp; arDataKonto(i) &amp; &quot;&lt;/cbc:AccountingCost&gt;&quot; &amp; CHR(13)	&apos; nicht erforderlich 0…1; [BT-133]
		END IF
		REM Nachlass auf für den Artikel, Anzahl der Artikel berücksichtigt. Muss also nicht mit der Artikelanzahl multipliziert werden.
		IF Val(arDataRabatt(i)) &gt; 0 THEN
			stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cac:AllowanceCharge&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…n	[BG-27, BG-28]
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:ChargeIndicator&gt;&quot; &amp; arDataRabattIndicator(i) &amp; &quot;&lt;/cbc:ChargeIndicator&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist; &quot;true&quot; für einen Aufschlag
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:AllowanceChargeReason&gt;Rabatt&lt;/cbc:AllowanceChargeReason&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1; Grund für den Nachlass	[BT-139, BT-144]
		&apos;	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:MultiplierFactorNumeric&gt;10.00&lt;/cbc:MultiplierFactorNumeric&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1; Angabe in Prozent*100
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:Amount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arDataRabatt(i) &amp; &quot;&lt;/cbc:Amount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn AllowanceCharge vorhanden ist	[BT-136,BT-141]
		&apos;	stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;cbc:BaseAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; stDataAmount(i) &amp; &quot;&lt;/cbc:BaseAmount&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1; Basisbetrag für die Prozentuale Ermäßigung
			stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;/cac:AllowanceCharge&gt;&quot; &amp; CHR(13) 
		END IF
		IF arDataStartDate(i) &lt;&gt; &quot;&quot; THEN
			stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cac:InvoicePeriod&gt;&quot; &amp; CHR(13)	&apos;nicht erforderlich 0…1	[BG-26]
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:StartDate&gt;&quot; &amp; arDataStartDate(i) &amp; &quot;&lt;/cbc:StartDate&gt;&quot; &amp; CHR(13) &apos;entweder Start oder End erforderlich 1…1, wenn InvoicePeriod vorhanden	[BT-134]
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:EndDate&gt;&quot; &amp; arDataEndDate(i) &amp; &quot;&lt;/cbc:EndDate&gt;&quot; &amp; CHR(13) &apos;entweder Start oder End erforderlich 1…1, wenn InvoicePeriod vorhanden	[BT-135]			
			stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;/cac:InvoicePeriod&gt;&quot; &amp; CHR(13)
    	END IF
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cac:Item&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-31]
		If arDataDescription(i) &lt;&gt; &quot;&quot; Then
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:Description&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1; kann ausführlicher sein	[BT-154]
			stString = stString &amp; arDataDescription(i) &amp; CHR(13)
			stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;/cbc:Description&gt;&quot; &amp; CHR(13)
		End if
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:Name&gt;&quot; &amp; arDataName(i) &amp; &quot;&lt;/cbc:Name&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-153]
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cac:SellersItemIdentification&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1
		stString = stString &amp; Space((4+t) * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arDataSellID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1, wenn SellersItemIdentification vorhanden ist	[BT-155]
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;/cac:SellersItemIdentification&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cac:ClassifiedTaxCategory&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-30]
		stString = stString &amp; Space((4+t) * inTab) &amp; &quot;&lt;cbc:ID&gt;&quot; &amp; arDataTaxID(i) &amp; &quot;&lt;/cbc:ID&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-151]
		stString = stString &amp; Space((4+t) * inTab) &amp; &quot;&lt;cbc:Percent&gt;&quot; &amp; arDataTax(i) &amp; &quot;&lt;/cbc:Percent&gt;&quot; &amp; CHR(13) &apos;nicht erforderlich 0…1; Angabe in Prozent*100, lässt sich aus dem Code von TaxCategory schließen	[BT-152]
		stString = stString &amp; Space((4+t) * inTab) &amp; &quot;&lt;cac:TaxScheme&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1
		stString = stString &amp; Space((5+t) * inTab) &amp; &quot;&lt;cbc:ID&gt;VAT&lt;/cbc:ID&gt;&quot; &amp; CHR(13) &apos;erforderlich 1…1; VAT: Value Added Tax → Mehrwertsteuer (Defaultwert)
		stString = stString &amp; Space((4+t) * inTab) &amp; &quot;&lt;/cac:TaxScheme&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;/cac:ClassifiedTaxCategory&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;/cac:Item&gt;&quot; &amp; CHR(13)
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;cac:Price&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BG-29]
		stString = stString &amp; Space((3+t) * inTab) &amp; &quot;&lt;cbc:PriceAmount currencyID=&quot;&quot;&quot; &amp; stDocumentCurrencyCode &amp; &quot;&quot;&quot;&gt;&quot; &amp; arDataPrice(i) &amp; &quot;&lt;/cbc:PriceAmount&gt;&quot; &amp; CHR(13)	&apos;erforderlich 1…1	[BT-146]
		stString = stString &amp; Space((2+t) * inTab) &amp; &quot;&lt;/cac:Price&gt;&quot; &amp; CHR(13)		
		IF arDataRow(i) = &quot;SubSub&quot; OR arDataRow(i) = &quot;SubSubToSub&quot; OR arDataRow(i) = &quot;SubSubToMain&quot; THEN
			stString = stString &amp; Space(3 * inTab) &amp; &quot;&lt;/cac:SubInvoiceLine&gt;&quot; &amp; CHR(13)
		END IF
		IF arDataRow(i) = &quot;Sub&quot; OR arDataRow(i) = &quot;SubToMain&quot; OR arDataRow(i) = &quot;SubSubToMain&quot; THEN
			stString = stString &amp; Space(2 * inTab) &amp; &quot;&lt;/cac:SubInvoiceLine&gt;&quot; &amp; CHR(13)
		END IF
		IF arDataRow(i) = &quot;Main&quot; OR arDataRow(i) = &quot;SubToMain&quot; OR arDataRow(i) = &quot;SubSubToMain&quot; THEN
			stString = stString &amp; Space(1 * inTab) &amp; &quot;&lt;/cac:InvoiceLine&gt;&quot; &amp; CHR(13)
		END IF
    NEXT
	stString = stString &amp; &quot;&lt;/ubl:Invoice&gt;&quot;
	oOutputStream.writeString(stString)
	oOutputStream.closeOutput()
END SUB

REM +++ Wird aus &quot;XRechnung → SaveXRechnung&quot; aufgerufen
FUNCTION Round2Decimalplaces(doVal AS DOUBLE) AS STRING
	DIM stTest AS STRING
	doVal = doVal*100
	IF Frac(doVal) &gt;= 0.5 OR (Frac(doVal) &lt; 0 AND Frac(doVal) &gt; -0.5) THEN
		doVal = doVal + 1
	END IF
	stTest = Trim(Str(Int(doVal)/100))
	If InStr(stTest, &quot;.&quot;) = 0 Then stTest = stTest  &amp; &quot;.00&quot;
    If ((Len(stTest) - InStr(stTest, &quot;.&quot;)) = 1) Then stTest = stTest  &amp; &quot;0&quot;
	Round2Decimalplaces = stTest
END FUNCTION

FUNCTION CharToXMLChar(stTest AS STRING) AS STRING
	stTest = Join(Split(stTest,&quot;&lt;&quot;),&quot;&amp;lt;&quot;)
	stTest = Join(Split(stTest,&quot;&gt;&quot;),&quot;&amp;gt;&quot;)
	stTest = Join(Split(stTest,&quot;&amp;&quot;),&quot;&amp;amp;&quot;)
	stTest = Join(Split(stTest,&quot;&quot;&quot;&quot;),&quot;&amp;quot;&quot;)
	stTest = Join(Split(stTest,&quot;&apos;&quot;),&quot;&amp;apos;&quot;)
	CharToXMLChar = stTest
END FUNCTION

</script:module>